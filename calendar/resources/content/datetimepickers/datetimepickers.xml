<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!--
    This defines <datepicker/> <timepicker/> and <datetimepicker/>
    which all descend from datetimepicker-base to get date/time parsing
    and consistent behavior.
    It relies on <minimonth/> for the date picker's drop down.
    You can be notified of change event as follows:
      <datepicker id="my-date-picker" onchange="myDatePick(this);"/>
    May get/set value in javascript with
      document.getElementById("my-date-picker").value = new Date();
    May disable/enable in javascript with
      document.getElementById("my-date-picker").disabled = true;
    May also disable/enable a datetimepicker's component
      datepicker or timepicker individually with
      document.getElementById("my-datetimepicker").datepickerdisabled = true;
      document.getElementById("my-datetimepicker").timepickerdisabled = true;
-->
<bindings id="xulDatePicker"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:html="http://www.w3.org/1999/xhtml"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="panellist" extends="chrome://messenger/content/menulist.xml#menulist-editable">
    <content sizetopopup="pref">
      <xul:hbox class="menulist-editable-box textbox-input-box" xbl:inherits="context,disabled,readonly,focused" flex="1">
        <html:input class="menulist-editable-input" flex="1" anonid="input" allowevents="true"
                    xbl:inherits="value=label,value,disabled,tabindex,readonly,placeholder"/>
      </xul:hbox>
      <xul:dropmarker class="menulist-dropmarker" type="menu"
                      xbl:inherits="open,disabled,parentfocused=focused"/>
      <children includes="panel"/>
    </content>
  </binding>

  <binding id="datetextpicker"
           extends="chrome://calendar/content/datetimepickers/datetimepickers.xml#datetimepicker-base">
    <content>
      <xul:hbox flex="1">
        <xul:textbox anonid="date-textbox" flex="1"
                     onfocus="this.select();"
                     onkeypress="if (event.key == 'Enter') fireGoEvent();"/>
        <xul:button anonid="date-go-button" oncommand="fireGoEvent()"/>
      </xul:hbox>
    </content>

    <implementation>
      <field name="mRelativeDates">[]</field>
      <field name="mDayNames">[]</field>
      <field name="mRelationWords">[]</field>
      <field name="mMonthLongNames">[]</field>
      <field name="mMonthShortNames">[]</field>

      <constructor><![CDATA[
          const { cal } = ChromeUtils.import("resource://calendar/modules/calUtils.jsm");
          let goButton = document.getAnonymousElementByAttribute(this, "anonid", "date-go-button");
          goButton.setAttribute("label", cal.l10n.getCalString("go"));
          // Load the stuff we're going to use to parse written dates
          this.mRelativeDates = [
              { word: cal.l10n.getCalString("today").toLowerCase(), offset: 0 },
              { word: cal.l10n.getCalString("yesterday").toLowerCase(), offset: -1 },
              { word: cal.l10n.getCalString("tomorrow").toLowerCase(), offset: 1 }];
          for (let i = 1; i <= 7; i++) {
              this.mDayNames.push(cal.l10n.getDateFmtString(`day.${i}.name`).toLowerCase());
          }

          for (let i = 1; i <= 12; i++) {
              this.mMonthLongNames.push(cal.l10n.getDateFmtString(`month.${i}.name`).toLowerCase());
              this.mMonthShortNames.push(cal.l10n.getDateFmtString(`month.${i}.Mmm`).toLowerCase());
          }

          // note that some languages have different conjugations of
          // next/last depending on the day
          this.mRelationWords = [
              { word: cal.l10n.getCalString("last1"), offset: -1 },
              { word: cal.l10n.getCalString("last2"), offset: -1 },
              { word: cal.l10n.getCalString("next1"), offset: 0 },
              { word: cal.l10n.getCalString("next2"), offset: 0 }];

          // Set the value to today
          let text = document.getAnonymousElementByAttribute(this, "anonid", "date-textbox");
          text.value = cal.l10n.getCalString("today");
      ]]></constructor>

      <property name="value">
        <getter><![CDATA[
            return this.mValue;
        ]]></getter>
        <setter><![CDATA[
            let text = document.getAnonymousElementByAttribute(this, "anonid", "date-textbox");
            try {
                text.value = this.formatDate(val);
            } catch (ex) {
                // Don't fail if date formatting fails.
            }
            return val;
        ]]></setter>
      </property>

      <method name="fireGoEvent">
        <body><![CDATA[
            let text = document.getAnonymousElementByAttribute(this, "anonid", "date-textbox");
            let date = this.parseLanguageDate(text.value);
            if (!date) {
                date = this.parseDateTime(text.value);
            }
            let prettyDate;
            if (date) {
                // format fails if year <= 1600 on win2k, so try format first.
                try {
                    prettyDate = this.formatDate(date);
                } catch (ex) {
                    // Don't fail if date formatting fails.
                }
            }
            if (date && prettyDate) {
                this.mValue = date;
                text.value = prettyDate;
                this.fireEvent("command", date);
            }
        ]]></body>
      </method>

      <!-- This function will take written (with words) dates and, if
         - possible, return a Date() object described by the words.  Note
         - that this function will not parse explicit dates, like 1/1/06,
         - you should use parseDateTime for that.
        -->
      <method name="parseLanguageDate">
        <parameter name="aValue"/>
        <body><![CDATA[
            if (!aValue) {
                return null;
            }
            let val = aValue.toLowerCase();
            // Look for the easy ones like today, tomorrow, etc
            for (let rel of this.mRelativeDates) {
                if (val == rel.word) {
                    let now = new Date();
                    now.setDate(now.getDate() + rel.offset);
                    return now;
                }
            }

            let self = this;

            // Takes a written day of the week and returns a js-date
            // corresponding to the nearest day in the future that is
            // that day of the week
            function getDateForDay(aWord) {
                for (let i in self.mDayNames) {
                    if (aWord != self.mDayNames[i]) {
                        continue;
                    }
                    // Figure out what day of the week today is.
                    let today = cal.dtz.now();

                    // i-weekday gets the offset. Add 7 to ensure that the %
                    // operation stays positive.
                    let offset = (i - today.weekday + 7) % 7;
                    today.day = today.day + offset;
                    return cal.dtz.dateTimeToJsDate(today);
                }
                return null;
            }

            // Remove commas
            val = val.replace(",", "");

            if (!val.includes(" ")) {
                // Just a single word, or a single date.
                return getDateForDay(val);
            }

            // Replace month names with numbers
            for (let i in this.mMonthLongNames) {
                if (val.includes(this.mMonthLongNames[i])) {
                    let newVal = val.replace(this.mMonthLongNames[i], Number(i) + 1);
                    newVal = newVal.replace(" ", "/");
                    return this.parseDateTime(newVal);
                }
            }

            // Same for short month names
            for (let i in this.mMonthShortNames) {
                if (val.includes(this.mMonthShortNames[i])) {
                    let newVal = val.replace(this.mMonthShortNames[i], Number(i) + 1);
                    newVal = newVal.replace(" ", "/");
                    return this.parseDateTime(newVal);
                }
            }

            // Now for the cool 'next' and 'last'
            let words = val.split(" ");
            let offset, day;
            for (let word of words) {
                for (let rel of this.mRelationWords) {
                    if (word == rel.word) {
                        offset = rel.offset;
                        break;
                    }
                }
                for (let i in this.mDayNames) {
                    if (word == this.mDayNames[i]) {
                        day = getDateForDay(word);
                        break;
                    }
                }
            }

            if (day && offset != undefined) {
                day.setDate(day.getDate() + (7 * offset));
                return day;
            }
            return null;
        ]]></body>
      </method>
    </implementation>
  </binding>

  <binding id="datetimepicker-base" extends="chrome://global/content/bindings/general.xml#basecontrol"
           inherits="value,onchange">
    <implementation>
      <constructor><![CDATA[
          this.kTimeFormatObject = { timeStyle: "short" };
          this.initDateFormat();
          this.initTimeFormat();
      ]]></constructor>

      <property name="value"
                onget="return this.mValue"
                onset="this.update(val, false)"/>

      <property name="lastDateParseIncludedTime"
                onget="return this.mLastDateParseIncludedTime;"
                onset="this.mLastDateParseIncludedTime = val;" />

      <method name="update">
        <parameter name="aValue"/>
        <parameter name="aRefresh"/>
        <body><![CDATA[
            if (aValue != null) {
                this.mValue = aValue;
            }
        ]]></body>
      </method>

      <method name="fireEvent">
        <parameter name="aEventName"/>
        <parameter name="aDetail"/>
        <body><![CDATA[
            let event = document.createEvent("Events");
            event.initEvent(aEventName, true, true);
            event.detail = aDetail;
            this.dispatchEvent(event);
        ]]></body>
      </method>

      <!-- Parameter aValue may be a date or a date time. Dates are
           read according to locale/OS setting (d-m-y or m-d-y or ...).
           (see initDateFormat). Uses parseTime() for times.
      -->
      <method name="parseDateTime">
        <parameter name="aValue"/>
        <body><![CDATA[
            this.mLastDateParseIncludedTime = false;
            let tempDate = null;
            if (!this.probeSucceeded) {
                return null; // avoid errors accessing uninitialized data.
            }

            let year = Number.MIN_VALUE;
            let month = -1;
            let day = -1;
            let timeString = null;

            if (this.alphaMonths == null) {
                // SHORT NUMERIC DATE, such as 2002-03-04, 4/3/2002, or CE2002Y03M04D.
                // Made of digits & nonDigits.  (Nondigits may be unicode letters
                // which do not match \w, esp. in CJK locales.)
                // (.*)? binds to null if no suffix.
                let parseNumShortDateRegex = /^\D*(\d+)\D+(\d+)\D+(\d+)(.*)?$/;
                let dateNumbersArray = parseNumShortDateRegex.exec(aValue);
                if (dateNumbersArray != null) {
                    year = Number(dateNumbersArray[this.yearIndex]);
                    month = Number(dateNumbersArray[this.monthIndex]) - 1; // 0-based
                    day = Number(dateNumbersArray[this.dayIndex]);
                    timeString = dateNumbersArray[4];
                }
            } else {
                // SHORT DATE WITH ALPHABETIC MONTH, such as "dd MMM yy" or "MMMM dd, yyyy"
                // (\d+|[^\d\W]) is digits or letters, not both together.
                // Allows 31dec1999 (no delimiters between parts) if OS does (w2k does not).
                // Allows Dec 31, 1999 (comma and space between parts)
                // (Only accepts ASCII month names; JavaScript RegExp does not have an
                // easy way to describe unicode letters short of a HUGE character range
                // regexp derived from the Alphabetic ranges in
                // http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt)
                // (.*)? binds to null if no suffix.
                let parseAlphShortDateRegex = /^\s*(\d+|[^\d\W]+)\W{0,2}(\d+|[^\d\W]+)\W{0,2}(\d+|[^\d\W]+)(.*)?$/;
                let datePartsArray = parseAlphShortDateRegex.exec(aValue);
                if (datePartsArray != null) {
                    year = Number(datePartsArray[this.yearIndex]);
                    let monthString = datePartsArray[this.monthIndex].toUpperCase();
                    for (let monthIdx = 0; monthIdx < this.alphaMonths.length; monthIdx++) {
                        if (monthString == this.alphaMonths[monthIdx]) {
                            month = monthIdx;
                            break;
                        }
                    }
                    day = Number(datePartsArray[this.dayIndex]);
                    timeString = datePartsArray[4];
                }
            }
            if (year != Number.MIN_VALUE && month != -1 && day != -1) {
                // year, month, day successfully parsed
                if (year >= 0 && year < 100) {
                    // If 0 <= year < 100, treat as 2-digit year (like formatDate):
                    //   parse year as up to 30 years in future or 69 years in past.
                    //   (Covers 30-year mortgage and most working people's birthdate.)
                    // otherwise will be treated as four digit year.
                    let currentYear = new Date().getFullYear();
                    let currentCentury = currentYear - currentYear % 100;
                    year = currentCentury + year;
                    if (year < currentYear - 69) {
                        year += 100;
                    }
                    if (year > currentYear + 30) {
                        year -= 100;
                    }
                }
                // if time is also present, parse it
                let hours = 0;
                let minutes = 0;
                let seconds = 0;
                if (timeString != null) {
                    let time = this.parseTime(timeString);
                    if (time != null) {
                        hours = time.getHours();
                        minutes = time.getMinutes();
                        seconds = time.getSeconds();
                        this.mLastDateParseIncludedTime = true;
                    }
                }
                tempDate = new Date(year, month, day, hours, minutes, seconds, 0);
            } // else did not match regex, not a valid date
            return tempDate;
        ]]></body>
      </method>

      <!-- Parse a variety of time formats so that cut and paste is likely to work.
           separator:            ':'         '.'        ' '        symbol        none
                                 "12:34:56"  "12.34.56" "12 34 56" "12h34m56s"   "123456"
           seconds optional:     "02:34"     "02.34"    "02 34"    "02h34m"      "0234"
           minutes optional:     "12"        "12"       "12"       "12h"         "12"
           1st hr digit optional:"9:34"      " 9.34"     "9 34"     "9H34M"       "934am"
           skip nondigit prefix  " 12:34"    "t12.34"   " 12 34"   "T12H34M"     "T0234"
           am/pm optional        "02:34 a.m.""02.34pm"  "02 34 A M" "02H34M P.M." "0234pm"
           am/pm prefix          "a.m. 02:34""pm02.34"  "A M 02 34" "P.M. 02H34M" "pm0234"
           am/pm cyrillic        "02:34\u0430.\u043c."  "02 34 \u0420 \u041c"
           am/pm arabic          "\u063502:34" (RTL 02:34a) "\u0645 02.34" (RTL 02.34 p)
           above/below noon      "\u4e0a\u534802:34"    "\u4e0b\u5348 02 34"
           noon before/after     "\u5348\u524d02:34"    "\u5348\u5f8c 02 34"
      -->
      <method name="parseTime">
        <parameter name="aValue"/>
        <body><![CDATA[
            let now = new Date();

            let noon = cal.l10n.getDateFmtString("noon");
            if (aValue.toLowerCase() == noon.toLowerCase()) {
                return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 12, 0, 0, 0);
            }

            let midnight = cal.l10n.getDateFmtString("midnight");
            if (aValue.toLowerCase() == midnight.toLowerCase()) {
                return new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
            }

            let time = null;
            let timePartsArray = this.parseTimeRegExp.exec(aValue);
            const PRE_INDEX = 1, HR_INDEX = 2, MIN_INDEX = 4, SEC_INDEX = 6, POST_INDEX = 8;

            if (timePartsArray != null) {
                let hoursString = timePartsArray[HR_INDEX];
                let hours = Number(hoursString);
                if (!(hours >= 0 && hours < 24)) {
                    return null;
                }

                let minutesString = timePartsArray[MIN_INDEX];
                let minutes = (minutesString == null ? 0 : Number(minutesString));
                if (!(minutes >= 0 && minutes < 60)) {
                    return null;
                }

                let secondsString = timePartsArray[SEC_INDEX];
                let seconds = (secondsString == null ? 0 : Number(secondsString));
                if (!(seconds >= 0 && seconds < 60)) {
                    return null;
                }

                let ampmCode = null;
                if (timePartsArray[PRE_INDEX] || timePartsArray[POST_INDEX]) {
                    if (this.ampmIndex && timePartsArray[this.ampmIndex]) {
                        // try current format order first
                        let ampmString = timePartsArray[this.ampmIndex];
                        if (this.amRegExp.test(ampmString)) {
                            ampmCode = "AM";
                        } else if (this.pmRegExp.test(ampmString)) {
                            ampmCode = "PM";
                        }
                    }
                    if (ampmCode == null) { // not yet found
                        // try any format order
                        let preString = timePartsArray[PRE_INDEX];
                        let postString = timePartsArray[POST_INDEX];
                        if ((preString && this.amRegExp.test(preString)) ||
                            (postString && this.amRegExp.test(postString))) {
                            ampmCode = "AM";
                        } else if ((preString && this.pmRegExp.test(preString)) ||
                                   (postString && this.pmRegExp.test(postString))) {
                            ampmCode = "PM";
                        } // else no match, ignore and treat as 24hour time.
                    }
                }
                if (ampmCode == "AM") {
                    if (hours == 12) {
                        hours = 0;
                    }
                } else if (ampmCode == "PM") {
                    if (hours < 12) {
                        hours += 12;
                    }
                }
                time = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, seconds, 0);
            }  // else did not match regex, not valid time
            return time;
        ]]></body>
      </method>

      <method name="initDateFormat">
        <body><![CDATA[
            // probe the dateformat
            this.yearIndex = -1;
            this.monthIndex = -1;
            this.dayIndex = -1;
            this.twoDigitYear = false;
            this.alphaMonths = null;
            this.probeSucceeded = false;
            this.mLastDateParseIncludedTime = false;

            // SHORT NUMERIC DATE, such as 2002-03-04, 4/3/2002, or CE2002Y03M04D.
            // Made of digits & nonDigits.  (Nondigits may be unicode letters
            // which do not match \w, esp. in CJK locales.)
            this.parseShortDateRegex = /^\D*(\d+)\D+(\d+)\D+(\d+)\D?$/;
            // Make sure to use UTC date and timezone here to avoid the pattern
            // detection to fail if the probe date output would have an timezone
            // offset due to our lack of support of historic timezone definitions.
            let probeDate = new Date(Date.UTC(2002, 3, 6)); // month is 0-based
            let probeString = this.formatDate(probeDate, cal.dtz.UTC);
            let probeArray = this.parseShortDateRegex.exec(probeString);
            if (probeArray) {
                // Numeric month format
                for (let i = 1; i <= 3; i++) {
                    switch (Number(probeArray[i])) {
                        case 2: this.twoDigitYear = true; // falls through
                        case 2002: this.yearIndex = i; break;
                        case 4: this.monthIndex = i; break;
                        case 5: // falls through for OS timezones western to GMT
                        case 6: this.dayIndex = i; break;
                    }
                }
                // All three indexes are set (not -1) at this point.
                this.probeSucceeded = true;
            } else {
                // SHORT DATE WITH ALPHABETIC MONTH, such as "dd MMM yy" or "MMMM dd, yyyy"
                // (\d+|[^\d\W]) is digits or letters, not both together.
                // Allows 31dec1999 (no delimiters between parts) if OS does (w2k does not).
                // Allows Dec 31, 1999 (comma and space between parts)
                // (Only accepts ASCII month names; JavaScript RegExp does not have an
                // easy way to describe unicode letters short of a HUGE character range
                // regexp derived from the Alphabetic ranges in
                // http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt)
                this.parseShortDateRegex = /^\s*(\d+|[^\d\W]+)\W{0,2}(\d+|[^\d\W]+)\W{0,2}(\d+|[^\d\W]+)\s*$/;
                probeArray = this.parseShortDateRegex.exec(probeString);
                if (probeArray != null) {
                    for (let j = 1; j <= 3; j++) {
                        switch (Number(probeArray[j])) {
                            case 2: this.twoDigitYear = true; // falls through
                            case 2002: this.yearIndex = j; break;
                            case 5: // falls through for OS timezones western to GMT
                            case 6: this.dayIndex = j; break;
                            default: this.monthIndex = j; break;
                        }
                    }
                    if (this.yearIndex != -1 && this.dayIndex != -1 && this.monthIndex != -1) {
                        this.probeSucceeded = true;
                        // Fill this.alphaMonths with month names.
                        this.alphaMonths = new Array(12);
                        for (let monthIdx = 0; monthIdx < 12; monthIdx++) {
                            probeDate.setMonth(monthIdx);
                            probeString = this.formatDate(probeDate);
                            probeArray = this.parseShortDateRegex.exec(probeString);
                            if (probeArray) {
                                this.alphaMonths[monthIdx] = probeArray[this.monthIndex].toUpperCase();
                            } else {
                                this.probeSucceeded = false;
                            }
                        }
                    }
                }
            }
            if (!this.probeSucceeded) {
                dump("\nOperating system short date format is not recognized: " + probeString + "\n");
            }
        ]]></body>
      </method>

      <!-- Time format in 24-hour format or 12-hour format with am/pm string.
           Should match formats
                HH:mm,       H:mm,       HH:mm:ss,       H:mm:ss
                hh:mm tt,    h:mm tt,    hh:mm:ss tt,    h:mm:ss tt
             tt hh:mm,    tt h:mm,    tt hh:mm:ss,    tt h:mm:ss
           where
           HH is 24 hour digits, with leading 0.  H is 24 hour digits, no leading 0.
           hh is 12 hour digits, with leading 0.  h is 12 hour digits, no leading 0.
           mm and ss are is minutes and seconds digits, with leading 0.
           tt is localized AM or PM string.
           ':' may be ':' or a units marker such as 'h', 'm', or 's' in  15h12m00s
           or may be omitted as in 151200.
      -->
      <method name="initTimeFormat">
        <body><![CDATA[
            const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");

            // probe the Time format
            this.ampmIndex = null;
            // Digits         HR       sep      MIN     sep      SEC     sep
            //   Index:       2        3        4       5        6       7
            let digitsExpr = "(\\d?\\d)(\\D)?(?:(\\d\\d)(\\D)?(?:(\\d\\d)(\\D)?)?)?";
            // any letters or '.': non-digit alphanumeric, period (a.m.), or space (P M)
            let anyAmPmExpr = "(?:[^\\d\\W]|[. ])+";
            // digitsExpr has 6 captures, so index of first ampmExpr is 1, of last is 8.
            let probeTimeRegExp =
                new RegExp("^(" + anyAmPmExpr + ")?\\s?" + digitsExpr + "(" + anyAmPmExpr + ")?\\s*$");
            const PRE_INDEX = 1, HR_INDEX = 2, MIN_INDEX = 4, SEC_INDEX = 6, POST_INDEX = 8; // eslint-disable-line no-unused-vars
            let amProbeTime = new Date(2000, 0, 1, 6, 12, 34);
            let pmProbeTime = new Date(2000, 0, 1, 18, 12, 34);
            let formatter = new Services.intl.DateTimeFormat(undefined, this.kTimeFormatObject);
            let amProbeString = formatter.format(amProbeTime);
            let pmProbeString = formatter.format(pmProbeTime);
            let amFormatExpr = null, pmFormatExpr = null;
            if (amProbeString != pmProbeString) {
                let amProbeArray = probeTimeRegExp.exec(amProbeString);
                let pmProbeArray = probeTimeRegExp.exec(pmProbeString);
                if (amProbeArray != null && pmProbeArray != null) {
                    if (amProbeArray[PRE_INDEX] && pmProbeArray[PRE_INDEX] &&
                        amProbeArray[PRE_INDEX] != pmProbeArray[PRE_INDEX]) {
                        this.ampmIndex = PRE_INDEX;
                    } else if (amProbeArray[POST_INDEX] && pmProbeArray[POST_INDEX]) {
                        if (amProbeArray[POST_INDEX] == pmProbeArray[POST_INDEX]) {
                            // check if need to append previous character,
                            // captured by the optional separator pattern after seconds digits,
                            // or after minutes if no seconds, or after hours if no minutes.
                            for (let k = SEC_INDEX; k >= HR_INDEX; k -= 2) {
                                let nextSepI = k + 1;
                                let nextDigitsI = k + 2;
                                if ((k == SEC_INDEX ||
                                     (!amProbeArray[nextDigitsI] && !pmProbeArray[nextDigitsI])) &&
                                    amProbeArray[nextSepI] && pmProbeArray[nextSepI] &&
                                    amProbeArray[nextSepI] != pmProbeArray[nextSepI]) {
                                    amProbeArray[POST_INDEX] =
                                      amProbeArray[nextSepI] + amProbeArray[POST_INDEX];
                                    pmProbeArray[POST_INDEX] =
                                      pmProbeArray[nextSepI] + pmProbeArray[POST_INDEX];
                                    this.ampmIndex = POST_INDEX;
                                    break;
                                }
                            }
                        } else {
                            this.ampmIndex = POST_INDEX;
                        }
                    }
                    if (this.ampmIndex) {
                        let makeFormatRegExp = function(string) {
                            // make expr to accept either as provided, lowercased, or uppercased
                            let regExp = string.replace(/(\W)/g, "[$1]"); // escape punctuation
                            let lowercased = string.toLowerCase();
                            if (string != lowercased) {
                                regExp += "|" + lowercased;
                            }
                            let uppercased = string.toUpperCase();
                            if (string != uppercased) {
                                regExp += "|" + uppercased;
                            }
                            return regExp;
                        };
                        amFormatExpr = makeFormatRegExp(amProbeArray[this.ampmIndex]);
                        pmFormatExpr = makeFormatRegExp(pmProbeArray[this.ampmIndex]);
                    }
                }
            }
            // International formats ([roman, cyrillic]|arabic|chinese/kanji characters)
            // covering languages of U.N. (en,fr,sp,ru,ar,zh) and G8 (en,fr,de,it,ru,ja).
            // See examples at parseTimeOfDay.
            let amExpr =
                "[Aa\u0410\u0430][. ]?[Mm\u041c\u043c][. ]?|\u0635|\u4e0a\u5348|\u5348\u524d";
            let pmExpr =
                "[Pp\u0420\u0440][. ]?[Mm\u041c\u043c][. ]?|\u0645|\u4e0b\u5348|\u5348\u5f8c";
            if (this.ampmIndex) {
                amExpr = amFormatExpr + "|" + amExpr;
                pmExpr = pmFormatExpr + "|" + pmExpr;
            }
            let ampmExpr = amExpr + "|" + pmExpr;
            // Must build am/pm formats into parse time regexp so that it can
            // match them without mistaking the initial char for an optional divider.
            // (For example, want to be able to parse both "12:34pm" and
            // "12H34M56Spm" for any characters H,M,S and any language's "pm".
            // The character between the last digit and the "pm" is optional.
            // Must recogize "pm" directly, otherwise in "12:34pm" the "S" pattern
            // matches the "p" character so only "m" is matched as ampm suffix.)
            //
            // digitsExpr has 6 captures, so index of first ampmExpr is 1, of last is 8.
            this.parseTimeRegExp =
                new RegExp("(" + ampmExpr + ")?\\s?" + digitsExpr + "(" + ampmExpr + ")?\\s*$");
            this.amRegExp = new RegExp("^(?:" + amExpr + ")$");
            this.pmRegExp = new RegExp("^(?:" + pmExpr + ")$");
        ]]></body>
      </method>

      <method name="formatDate">
        <parameter name="aDate"/>
        <parameter name="aTimezone"/>
        <body><![CDATA[
            // Usually, floating is ok here, so no need to pass aTimezone - we just need to pass
            // it in if we need to make sure formatting happens without a timezone conversion.
            let timezone = aTimezone || cal.dtz.floating;
            return cal.getDateFormatter().formatDateShort(
                cal.dtz.jsDateToDateTime(aDate, timezone)
            );
        ]]></body>
      </method>

      <method name="formatTime">
        <parameter name="aValue"/>
        <body><![CDATA[
            const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");

            let formatter = new Services.intl.DateTimeFormat(undefined, this.kTimeFormatObject);
            return formatter.format(aValue);
        ]]></body>
      </method>
    </implementation>
  </binding>
</bindings>
