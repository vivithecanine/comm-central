<?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- import-globals-from ../calendar-ui-utils.js -->
<!-- import-globals-from calendar-event-dialog-attendees.js -->

<!DOCTYPE dialog [
  <!ENTITY % dtd1 SYSTEM "chrome://calendar/locale/global.dtd" > %dtd1;
  <!ENTITY % dtd2 SYSTEM "chrome://calendar/locale/calendar.dtd" > %dtd2;
  <!ENTITY % dtd3 SYSTEM "chrome://calendar/locale/calendar-event-dialog.dtd"> %dtd3;
]>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <!-- the 'selection-bar' binding implements the vertical bar that provides
       a visual indication for the time range the event is configured for. -->
  <binding id="selection-bar">
    <content>
      <xul:scrollbox anonid="scrollbox" width="0" orient="horizontal" flex="1">
        <xul:box class="selection-bar" anonid="selection-bar">
          <xul:box class="selection-bar-left" anonid="leftbox"/>
          <xul:spacer class="selection-bar-spacer" flex="1"/>
          <xul:box class="selection-bar-right" anonid="rightbox"/>
        </xul:box>
      </xul:scrollbox>
    </content>

    <implementation>
      <field name="mRange">0</field>
      <field name="mStartHour">0</field>
      <field name="mEndHour">24</field>
      <field name="mContentWidth">0</field>
      <field name="mHeaderHeight">0</field>
      <field name="mRatio">0</field>
      <field name="mBaseDate">null</field>
      <field name="mStartDate">null</field>
      <field name="mEndDate">null</field>
      <field name="mMouseX">0</field>
      <field name="mMouseY">0</field>
      <field name="mDragState">0</field>
      <field name="mMargin">0</field>
      <field name="mWidth">0</field>
      <field name="mForce24Hours">false</field>
      <field name="mZoomFactor">100</field>
      <!-- constant that defines at which ratio an event is clipped, when moved or resized -->
      <field name="mfClipRatio">0.7</field>
      <field name="mLeftBox"/>
      <field name="mRightBox"/>
      <field name="mSelectionbar"/>

      <property name="zoomFactor">
        <getter><![CDATA[
            return this.mZoomFactor;
        ]]></getter>
        <setter><![CDATA[
            this.mZoomFactor = val;
            return val;
        ]]></setter>
      </property>

      <property name="force24Hours">
        <getter><![CDATA[
            return this.mForce24Hours;
        ]]></getter>
        <setter><![CDATA[
            this.mForce24Hours = val;
            this.initTimeRange();
            this.update();
            return val;
        ]]></setter>
      </property>

      <property name="ratio">
        <setter><![CDATA[
            this.mRatio = val;
            this.update();
            return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
          this.initTimeRange();

          // The basedate is the date/time from which the display
          // of the timebar starts. The range is the number of days
          // we should be able to show. the start- and enddate
          // is the time the event is scheduled for.
          this.mRange = Number(this.getAttribute("range"));
          this.mSelectionbar = document.getAnonymousElementByAttribute(this, "anonid", "selection-bar");
      ]]></constructor>

      <property name="baseDate">
        <setter><![CDATA[
            // we need to convert the date/time in question in
            // order to calculate with hours that are aligned
            // with our timebar display.
            let kDefaultTimezone = cal.dtz.defaultTimezone;
            this.mBaseDate = val.getInTimezone(kDefaultTimezone);
            this.mBaseDate.isDate = true;
            this.mBaseDate.makeImmutable();
            return val;
        ]]></setter>
      </property>

      <property name="startDate">
        <setter><![CDATA[
            // currently we *always* set the basedate to be
            // equal to the startdate. we'll most probably
            // want to change this later.
            this.baseDate = val;
            // we need to convert the date/time in question in
            // order to calculate with hours that are aligned
            // with our timebar display.
            let kDefaultTimezone = cal.dtz.defaultTimezone;
            this.mStartDate = val.getInTimezone(kDefaultTimezone);
            this.mStartDate.makeImmutable();
            return val;
        ]]></setter>
        <getter><![CDATA[
            return this.mStartDate;
        ]]></getter>
      </property>

      <property name="endDate">
        <setter><![CDATA[
            // we need to convert the date/time in question in
            // order to calculate with hours that are aligned
            // with our timebar display.
            let kDefaultTimezone = cal.dtz.defaultTimezone;
            this.mEndDate = val.getInTimezone(kDefaultTimezone);
            if (this.mEndDate.isDate) {
                this.mEndDate.day += 1;
            }
            this.mEndDate.makeImmutable();
            return val;
        ]]></setter>
        <getter><![CDATA[
            return this.mEndDate;
        ]]></getter>
      </property>

      <property name="leftdragWidth">
        <getter><![CDATA[
            if (!this.mLeftBox) {
                this.mLeftBox =
                    document.getAnonymousElementByAttribute(
                        this, "anonid", "leftbox");
            }
            return this.mLeftBox.boxObject.width;
        ]]></getter>
      </property>
      <property name="rightdragWidth">
        <getter><![CDATA[
            if (!this.mRightBox) {
                this.mRightBox =
                    document.getAnonymousElementByAttribute(
                        this, "anonid", "rightbox");
            }
            return this.mRightBox.boxObject.width;
        ]]></getter>
      </property>

      <method name="init">
        <parameter name="width"/>
        <parameter name="height"/>
        <body><![CDATA[
            this.mContentWidth = width;
            this.mHeaderHeight = height + 2;
            this.mMargin = 0;
            this.update();
        ]]></body>
      </method>

      <!-- given some specific date this method calculates the
           corrposonding offset in fractional hours -->
      <method name="date2offset">
        <parameter name="date"/>
        <body><![CDATA[
            let num_hours = this.mEndHour - this.mStartHour;
            let diff = date.subtractDate(this.mBaseDate);
            let offset = diff.days * num_hours;
            let hours = (diff.hours - this.mStartHour) + (diff.minutes / 60.0);
            if (hours < 0) {
                hours = 0;
            }
            if (hours > num_hours) {
                hours = num_hours;
            }
            offset += hours;
            return offset;
        ]]></body>
      </method>

      <method name="update">
        <body><![CDATA[
            if (!this.mStartDate || !this.mEndDate) {
                return;
            }

            // Calculate the relation of startdate/basedate and enddate/startdate.
            let offset = this.mStartDate.subtractDate(this.mBaseDate);

            // Calculate how much pixels a single hour and a single day take up.
            let num_hours = this.mEndHour - this.mStartHour;
            let hour_width = this.mContentWidth / num_hours;

            // Calculate the offset in fractional hours that corrospond
            // to our start- and end-time.
            let start_offset_in_hours = this.date2offset(this.mStartDate);
            let end_offset_in_hours = this.date2offset(this.mEndDate);
            let duration_in_hours = end_offset_in_hours - start_offset_in_hours;

            // Calculate width & margin for the selection bar based on the
            // relation of startdate/basedate and enddate/startdate.
            // This is a simple conversion from hours to pixels.
            this.mWidth = duration_in_hours * hour_width;
            let totaldragwidths = this.leftdragWidth + this.rightdragWidth;
            if (this.mWidth < totaldragwidths) {
                this.mWidth = totaldragwidths;
            }
            this.mMargin = start_offset_in_hours * hour_width;

            // Calculate the difference between content and container in pixels.
            // The container is the window showing this control, the content is the
            // total number of pixels the selection bar can theoretically take up.
            let total_width = this.mContentWidth * this.mRange - this.parentNode.boxObject.width;

            // Calculate the current scroll offset.
            offset = Math.floor(total_width * this.mRatio);

            // The final margin is the difference between the date-based margin
            // and the scroll-based margin.
            this.mMargin -= offset;

            // Set the styles based on the calculations above for the 'selection-bar'.
            let style = "width: " + this.mWidth +
                        "px; margin-inline-start: " + this.mMargin +
                        "px; margin-top: " + this.mHeaderHeight + "px;";
            this.mSelectionbar.setAttribute("style", style);

            let event = document.createEvent("Events");
            event.initEvent("timechange", true, false);
            event.startDate = this.mStartDate;
            event.endDate = this.mEndDate.clone();
            if (event.endDate.isDate) {
                event.endDate.day--;
            }
            event.endDate.makeImmutable();
            this.dispatchEvent(event);
        ]]></body>
      </method>

      <method name="setWidth">
        <parameter name="width"/>
        <body><![CDATA[
            let scrollbox =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "scrollbox");
            scrollbox.setAttribute("width", width);
        ]]></body>
      </method>

      <method name="initTimeRange">
        <body><![CDATA[
            if (this.force24Hours) {
                this.mStartHour = 0;
                this.mEndHour = 24;
            } else {
                this.mStartHour = Services.prefs.getIntPref("calendar.view.daystarthour", 8);
                this.mEndHour = Services.prefs.getIntPref("calendar.view.dayendhour", 19);
            }
        ]]></body>
      </method>

      <method name="moveTime">
        <parameter name="time"/>
        <parameter name="delta"/>
        <parameter name="doclip"/>
        <body><![CDATA[
            let newTime = time.clone();
            let clip_minutes = 60 * this.zoomFactor / 100;
            if (newTime.isDate) {
                clip_minutes = 60 * 24;
            }
            let num_hours = this.mEndHour - this.mStartHour;
            let hour_width = this.mContentWidth / num_hours;
            let minutes_per_pixel = 60 / hour_width;
            let minute_shift = minutes_per_pixel * delta;
            let isClipped = Math.abs(minute_shift) >= (this.mfClipRatio * clip_minutes);
            if (isClipped) {
                if (delta > 0) {
                    if (time.isDate) {
                        newTime.day++;
                    } else {
                        if (doclip) {
                            newTime.minute -= newTime.minute % clip_minutes;
                        }
                        newTime.minute += clip_minutes;
                    }
                } else if (delta < 0) {
                    if (time.isDate) {
                        newTime.day--;
                    } else {
                        if (doclip) {
                            newTime.minute -= newTime.minute % clip_minutes;
                        }
                        newTime.minute -= clip_minutes;
                    }
                }
            }

            if (!newTime.isDate) {
                if (newTime.hour < this.mStartHour) {
                    newTime.hour = this.mEndHour - 1;
                    newTime.day--;
                }
                if (newTime.hour >= this.mEndHour) {
                    newTime.hour = this.mStartHour;
                    newTime.day++;
                }
            }

            return newTime;
        ]]></body>
      </method>
    </implementation>

    <handlers>
      <handler event="mousedown"><![CDATA[
          let element = event.target;
          this.mMouseX = event.screenX;
          let mouseX = event.clientX - element.boxObject.x;

          if (mouseX >= this.mMargin) {
              if (mouseX <= (this.mMargin + this.mWidth)) {
                  if (mouseX <= (this.mMargin + this.leftdragWidth)) {
                      // Move the startdate only...
                      window.setCursor("w-resize");
                      this.mDragState = 2;
                  } else if (mouseX >= (this.mMargin + this.mWidth - (this.rightdragWidth))) {
                      // Move the enddate only..
                      window.setCursor("e-resize");
                      this.mDragState = 3;
                  } else {
                      // Move the startdate and the enddate
                      this.mDragState = 1;
                      window.setCursor("grab");
                  }
              }
          }
      ]]></handler>

      <handler event="mousemove"><![CDATA[
          let mouseX = event.screenX;
          if (this.mDragState == 1) {
              // Move the startdate and the enddate
              let delta = mouseX - this.mMouseX;
              let newStart = this.moveTime(this.mStartDate, delta, false);
              if (newStart.compare(this.mStartDate) != 0) {
                  let newEnd = this.moveTime(this.mEndDate, delta, false);

                  // We need to adapt this date in case we're dealing with
                  // an all-day event. This is because setting 'endDate' will
                  // automatically add one day extra for all-day events.
                  if (newEnd.isDate) {
                      newEnd.day--;
                  }

                  this.startDate = newStart;
                  this.endDate = newEnd;
                  this.mMouseX = mouseX;
                  this.update();
              }
          } else if (this.mDragState == 2) {
              // Move the startdate only...
              let delta = event.screenX - this.mSelectionbar.boxObject.screenX;
              let newStart = this.moveTime(this.mStartDate, delta, true);
              if (newStart.compare(this.mEndDate) >= 0) {
                  if (this.mStartDate.isDate) {
                      return;
                  }
                  newStart = this.mEndDate;
              }
              if (newStart.compare(this.mStartDate) != 0) {
                  this.startDate = newStart;
                  this.update();
              }
          } else if (this.mDragState == 3) {
              // Move the enddate only..
              let delta = mouseX - (this.mSelectionbar.boxObject.screenX +
                                    this.mSelectionbar.boxObject.width);
              let newEnd = this.moveTime(this.mEndDate, delta, true);
              if (newEnd.compare(this.mStartDate) < 0) {
                  newEnd = this.mStartDate;
              }
              if (newEnd.compare(this.mEndDate) != 0) {
                  // We need to adapt this date in case we're dealing with
                  // an all-day event. This is because setting 'endDate' will
                  // automatically add one day extra for all-day events.
                  if (newEnd.isDate) {
                      newEnd.day--;
                  }

                  // Don't allow all-day events to be shorter than a single day.
                  if (!newEnd.isDate || (newEnd.compare(this.startDate) >= 0)) {
                      this.endDate = newEnd;
                      this.update();
                  }
              }
          }
      ]]></handler>

      <handler event="mouseup"><![CDATA[
          this.mDragState = 0;
          window.setCursor("auto");
      ]]></handler>
    </handlers>
  </binding>
</bindings>
