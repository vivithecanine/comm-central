<?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- import-globals-from ../calendar-ui-utils.js -->
<!-- import-globals-from calendar-event-dialog-attendees.js -->

<!DOCTYPE dialog [
  <!ENTITY % dtd1 SYSTEM "chrome://calendar/locale/global.dtd" > %dtd1;
  <!ENTITY % dtd2 SYSTEM "chrome://calendar/locale/calendar.dtd" > %dtd2;
  <!ENTITY % dtd3 SYSTEM "chrome://calendar/locale/calendar-event-dialog.dtd" > %dtd3;
]>

<bindings xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

  <binding id="scroll-container">
    <content>
      <xul:box class="container"
               xbl:inherits="flex"
               anonid="container"
               style="overflow: hidden; clip: rect(0px 0px 0px 0px);">
        <xul:box class="content"
                 xbl:inherits="flex,orient"
                 anonid="content">
          <children/>
        </xul:box>
      </xul:box>
    </content>

    <implementation>
      <property name="x">
        <getter><![CDATA[
            let content =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "content");
            let margin = getComputedStyle(content, null).marginInlineStart;
            return -parseInt(margin.replace(/px/, ""), 10);
        ]]></getter>
        <setter><![CDATA[
            let content =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "content");
            content.setAttribute("style",
                                 "margin-inline-start: " + (-val) + "px;");
            return val;
        ]]></setter>
      </property>

      <property name="y">
        <getter><![CDATA[
            let content =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "content");
            let margin = getComputedStyle(content, null).marginTop;
            return -parseInt(margin.replace(/px/, ""), 10);
        ]]></getter>
        <setter><![CDATA[
            let content =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "content");
            content.setAttribute("style",
                                 "margin-top: " + (-val) + "px;");
            return val;
        ]]></setter>
      </property>
    </implementation>
  </binding>

  <binding id="freebusy-day">
    <content>
      <xul:box orient="vertical">
        <xul:text class="freebusy-timebar-title"
                  style="font-weight:bold;"
                  anonid="day"/>
        <xul:box equalsize="always" anonid="hours"/>
      </xul:box>
    </content>

    <implementation>
      <field name="mDateFormatter">null</field>
      <field name="mStartDate">null</field>
      <field name="mEndDate">null</field>
      <field name="mStartHour">0</field>
      <field name="mEndHour">24</field>
      <field name="mForce24Hours">false</field>
      <field name="mZoomFactor">100</field>

      <property name="zoomFactor">
        <getter><![CDATA[
            return this.mZoomFactor;
        ]]></getter>
        <setter><![CDATA[
            this.mZoomFactor = val;
            let hours = document.getAnonymousElementByAttribute(this, "anonid", "hours");
            removeChildren(hours);
            return val;
        ]]></setter>
      </property>

      <property name="force24Hours">
        <getter><![CDATA[
            return this.mForce24Hours;
        ]]></getter>
        <setter><![CDATA[
            this.mForce24Hours = val;
            this.initTimeRange();

            let hours = document.getAnonymousElementByAttribute(this, "anonid", "hours");
            removeChildren(hours);
            return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
          this.initTimeRange();
      ]]></constructor>

      <method name="initTimeRange">
        <body><![CDATA[
            if (this.force24Hours) {
                this.mStartHour = 0;
                this.mEndHour = 24;
            } else {
                const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");

                this.mStartHour = Services.prefs.getIntPref("calendar.view.daystarthour", 8);
                this.mEndHour = Services.prefs.getIntPref("calendar.view.dayendhour", 19);
            }
        ]]></body>
      </method>

      <property name="startDate">
        <setter><![CDATA[
            this.mStartDate = val.clone();
            this.mStartDate.minute = 0;
            this.mStartDate.second = 0;
            this.mStartDate.makeImmutable();
            return val;
        ]]></setter>
      </property>

      <property name="endDate">
        <setter><![CDATA[
            this.mEndDate = val.clone();
            this.mEndDate.makeImmutable();
            return val;
        ]]></setter>
      </property>

      <property name="dayHeight">
        <getter><![CDATA[
            let day =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "day");
            return day.getBoundingClientRect().height;
        ]]></getter>
      </property>

      <property name="date">
        <setter><![CDATA[
            let date = val.clone();
            date.hour = 0;
            date.minute = 0;
            date.isDate = false;

            if (!this.mDateFormatter) {
                this.mDateFormatter = Cc["@mozilla.org/calendar/datetime-formatter;1"]
                                        .getService(Ci.calIDateTimeFormatter);
            }

            // First set the formatted date string as title
            let day =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "day");
            let dateValue = this.mZoomFactor > 100 ? this.mDateFormatter.formatDateShort(date)
                                                   : this.mDateFormatter.formatDateLong(date);
            day.setAttribute("value", dateValue);

            // Now create as many 'hour' elements as needed
            let step_in_minutes = Math.floor(60 * this.mZoomFactor / 100);
            let hours =
                document.getAnonymousElementByAttribute(
                    this, "anonid", "hours");
            date.hour = this.mStartHour;
            if (hours.childNodes.length <= 0) {
                let template = document.createXULElement("text");
                template.className = "freebusy-timebar-hour";
                let count = Math.ceil(
                    (this.mEndHour - this.mStartHour) * 60 / step_in_minutes);
                let remain = count;
                let first = true;
                while (remain--) {
                    let newNode = template.cloneNode(false);
                    let value = this.mDateFormatter.formatTime(date);
                    if (first) {
                        newNode.classList.add("first-in-day");
                        first = false;
                    }
                    newNode.setAttribute("value", value);
                    hours.appendChild(newNode);
                    date.minute += step_in_minutes;

                    if (remain == 0) {
                        newNode.classList.add("last-in-day");
                    }
                }
            }

            return val;
        ]]></setter>
      </property>
    </implementation>
  </binding>

  <binding id="freebusy-grid" extends="chrome://messenger/content/richlistbox.xml#xbl-richlistbox">
    <implementation>
      <field name="mContentHeight">0</field>
      <field name="mRowHeight">0</field>
      <field name="mMaxFreeBusy">0</field>
      <field name="mPendingRequests">null</field>
      <field name="mStartDate">null</field>
      <field name="mEndDate">null</field>
      <field name="mScrollOffset">0</field>
      <field name="mRange">0</field>
      <field name="mStartHour">0</field>
      <field name="mEndHour">24</field>
      <field name="mForce24Hours">false</field>
      <field name="mZoomFactor">100</field>

      <property name="zoomFactor">
        <getter><![CDATA[
            return this.mZoomFactor;
        ]]></getter>
        <setter><![CDATA[
            this.mZoomFactor = val;
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                let freebusy = this.getFreeBusyElement(i);
                freebusy.zoomFactor = this.mZoomFactor;
            }
            this.forceRefresh();
            return val;
        ]]></setter>
      </property>

      <property name="force24Hours">
        <getter><![CDATA[
            return this.mForce24Hours;
        ]]></getter>
        <setter><![CDATA[
            this.mForce24Hours = val;
            this.initTimeRange();
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                let freebusy = this.getFreeBusyElement(i);
                freebusy.force24Hours = this.mForce24Hours;
            }
            return val;
        ]]></setter>
      </property>

      <property name="firstVisibleRow">
        <getter><![CDATA[
            return this.getIndexOfFirstVisibleRow();
        ]]></getter>
        <setter><![CDATA[
            this.scrollToIndex(val);
            return val;
        ]]></setter>
      </property>

      <property name="ratio">
        <setter><![CDATA[
            let rowcount = this.getRowCount();
            this.scrollToIndex(Math.floor(rowcount * val));
            return val;
        ]]></setter>
      </property>

      <constructor><![CDATA[
          this.initTimeRange();

          let grid = document.getElementById("freebusy-grid");
          this.mRange = Number(grid.getAttribute("range"));

          this.mMaxFreeBusy = 0;
          this.mPendingRequests = [];

          window.addEventListener("load", this.onLoad.bind(this), true);
          window.addEventListener("unload", this.onUnload.bind(this), true);
      ]]></constructor>

      <property name="startDate">
        <getter><![CDATA[
            return this.mStartDate;
        ]]></getter>
        <setter><![CDATA[
            this.mStartDate = val.clone();
            this.mStartDate.makeImmutable();
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                this.getFreeBusyElement(i).startDate = val;
            }
            return val;
        ]]></setter>
      </property>

      <property name="endDate">
        <getter><![CDATA[
            return this.mEndDate;
        ]]></getter>
        <setter><![CDATA[
            this.mEndDate = val.clone();
            this.mEndDate.makeImmutable();
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                this.getFreeBusyElement(i).endDate = val;
            }
            return val;
        ]]></setter>
      </property>

      <property name="documentSize">
        <getter><![CDATA[
            return this.getFreeBusyElement(1).documentSize;
        ]]></getter>
      </property>

      <method name="onLoad">
        <body><![CDATA[
            this.onInitialize();
        ]]></body>
      </method>

      <method name="onUnload">
        <body><![CDATA[
            // Cancel pending free/busy requests
            for (let request of this.mPendingRequests) {
                request.cancel(null);
            }

            this.mPendingRequests = [];
        ]]></body>
      </method>

      <method name="onInitialize">
        <body><![CDATA[
            let args = window.arguments[0];
            let startTime = args.startTime;
            let endTime = args.endTime;

            let kDefaultTimezone = cal.dtz.defaultTimezone;
            this.startDate = startTime.getInTimezone(kDefaultTimezone);
            this.endDate = endTime.getInTimezone(kDefaultTimezone);

            let template = this.getElementsByTagName("richlistitem")[0];
            this.appendNewRow(template, null);
            template.remove();

            this.updateFreeBusy();
        ]]></body>
      </method>

      <method name="onChangeCalendar">
        <parameter name="calendar"/>
        <body><![CDATA[
        ]]></body>
      </method>

      <!-- appends a new empty row -->
      <method name="appendNewRow">
        <parameter name="aTemplateNode"/>
        <parameter name="aReplaceNode"/>
        <body><![CDATA[
            this.mMaxFreeBusy++;
            let newNode = aTemplateNode.cloneNode(true);
            if (aReplaceNode) {
                this.replaceChild(newNode, aReplaceNode);
            } else {
                this.appendChild(newNode);
            }

            let grid = newNode.getElementsByTagName("calendar-event-freebusy-row")[0];

            // Propagate start/enddate to the new row.
            grid.startDate = this.mStartDate;
            grid.endDate = this.mEndDate;

            grid.force24Hours = this.mForce24Hours;
            grid.zoomFactor = this.mZoomFactor;

            // We always clone the first row.  The problem is that the first row
            // could be focused.  When we clone that row, we end up with a cloned
            // XUL textbox that has a focused attribute set.  Therefore we think
            // we're focused and don't properly refocus.  The best solution to this
            // would be to clone a template row that didn't really have any presentation,
            // rather than using the real visible first row of the listbox.
            // For now we'll just put in a hack that ensures the focused attribute
            // is never copied when the node is cloned.
            if (grid.getAttribute("focused") != "") {
                grid.removeAttribute("focused");
            }
        ]]></body>
      </method>

      <property name="scroll">
        <setter><![CDATA[
            this.mScrollOffset = val;
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                this.getFreeBusyElement(i).scroll = val;
            }
            return val;
        ]]></setter>
      </property>

      <method name="onModify">
        <parameter name="event"/>
        <body><![CDATA[
            // Add or remove rows depending on the number of items
            // contained in the list passed as argument.
            let list = event.details;
            if (this.mMaxFreeBusy != list.length) {
                let template = this.getElementsByTagName("richlistitem")[0];
                while (this.mMaxFreeBusy < list.length) {
                    let nextDummy = this.getNextDummyRow();
                    this.appendNewRow(template, nextDummy);
                    template = this.getElementsByTagName("richlistitem")[0];
                }
                while (this.mMaxFreeBusy > list.length) {
                    this.deleteRow(this.mMaxFreeBusy);
                }
            }

            // Store the attributes in our grid rows.
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                let freebusy = this.getFreeBusyElement(i);
                freebusy.setAttribute("calid", list[i - 1].calid);
                freebusy.removeAttribute("dirty");
                if (list[i - 1].dirty) {
                    freebusy.setAttribute("dirty", "true");
                }
            }

            // Align all rows
            this.scroll = this.mScrollOffset;

            this.updateFreeBusy();
        ]]></body>
      </method>

      <!-- updateFreeBusy(), implementation of the core functionality of this binding -->
      <method name="updateFreeBusy">
        <body><![CDATA[
            let fbService = cal.getFreeBusyService();
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                // Retrieve the string from the appropriate row
                let freebusy = this.getFreeBusyElement(i);
                if (freebusy.hasAttribute("dirty")) {
                    freebusy.removeAttribute("dirty");
                    let calid = freebusy.getAttribute("calid");
                    if (calid && calid.length > 0) {
                        // Define the datetime range we would like to ask for.
                        let start = this.mStartDate.clone();
                        start.hour = 0;
                        start.minute = 0;
                        start.second = 0;
                        let end = start.clone();
                        end.day += this.mRange;
                        // Update with 'no data available' until response will be received
                        freebusy.onFreeBusy(null);
                        try {
                            let listener = new calFreeBusyListener(freebusy, this);
                            let request = fbService.getFreeBusyIntervals(calid,
                                                                         start,
                                                                         end,
                                                                         Ci.calIFreeBusyInterval.BUSY_ALL,
                                                                         listener);
                            if (request && request.isPending) {
                                this.mPendingRequests.push(request);
                            }
                        } catch (ex) {
                            Cu.reportError(ex);
                        }
                    }
                }
            }
        ]]></body>
      </method>

      <method name="nextSlot">
        <body><![CDATA[
            let startTime = this.mStartDate.clone();
            let endTime = this.mEndDate.clone();

            startTime.isDate = false;
            endTime.isDate = false;

            let allDay = this.mStartDate.isDate;
            let step_in_minutes = Math.floor(60 * this.zoomFactor / 100);
            if (allDay) {
                step_in_minutes = 60 * 24;
                endTime.day++;
            }

            let duration = endTime.subtractDate(startTime);

            startTime.minute += step_in_minutes;

            if (startTime.hour < this.mStartHour) {
                startTime.hour = this.mStartHour;
                startTime.minute = 0;
            }

            endTime = startTime.clone();
            endTime.addDuration(duration);
            if (endTime.hour > this.mEndHour) {
                startTime.day++;
                startTime.hour = this.mStartHour;
                startTime.minute = 0;
                endTime = startTime.clone();
                endTime.addDuration(duration);
                if (endTime.hour > this.mEndHour) {
                    return this.mStartDate.clone();
                }
            }

            // Now iterate all freebusy-rows and ask each one
            // if it wants to modify the suggested time slot.
            // we keep iterating the rows until all of them
            // are happy with it.
            let recheck;
            do {
                recheck = false;

                for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                    let row = this.getFreeBusyElement(i);
                    let newTime = row.nextSlot(startTime, endTime, allDay);
                    if (newTime) {
                        if (newTime.compare(startTime) != 0) {
                            startTime = newTime;

                            if (startTime.hour < this.mStartHour) {
                                startTime.hour = this.mStartHour;
                                startTime.minute = 0;
                            }

                            endTime = startTime.clone();
                            endTime.addDuration(duration);

                            if (endTime.hour > this.mEndHour) {
                                startTime.day++;
                                startTime.hour = this.mStartHour;
                                startTime.minute = 0;
                                endTime = startTime.clone();
                                endTime.addDuration(duration);
                            }

                            recheck = true;
                        }
                    } else {
                        // A new slot could not be found
                        // and the given time was also invalid.
                        return this.mStartDate.clone();
                    }
                }
            } while (recheck);

            // Return the unmodifed startdate of the item
            // in case no possible match was found.
            if (startTime.compare(this.mStartDate) == 0) {
                return this.mStartDate.clone();
            }

            // Special case for allday events - if the original
            // datetime was indeed a date we need to carry this
            // state over to the calculated datetime.
            if (this.mStartDate.isDate) {
                startTime.isDate = true;
            }

            // In case the new starttime happens to be scheduled
            // on a different day, we also need to update the
            // complete freebusy information and appropriate
            // underlying arrays holding the information.
            if (this.mStartDate.day != startTime.day) {
                for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                    let fbelem = this.getFreeBusyElement(i);
                    fbelem.setAttribute("dirty", "true");
                }
                this.updateFreeBusy();
            }

            // Return the new starttime of the item.
            return startTime;
        ]]></body>
      </method>

      <method name="forceRefresh">
        <body><![CDATA[
            for (let i = 1; i <= this.mMaxFreeBusy; i++) {
                let row = this.getFreeBusyElement(i);
                row.setAttribute("dirty", "true");
            }
            this.updateFreeBusy();
        ]]></body>
      </method>

      <!-- This method returns the <xul:richlistitem> at row number 'aRow' -->
      <method name="getListItem">
        <parameter name="aRow"/>
        <body><![CDATA[
            return this.getElementsByTagName("richlistitem")[aRow - 1];
        ]]></body>
      </method>

      <method name="getFreeBusyElement">
        <parameter name="aRow"/>
        <body><![CDATA[
            return this.getListItem(aRow).getElementsByTagName("calendar-event-freebusy-row")[0];
        ]]></body>
      </method>

      <method name="deleteRow">
        <parameter name="aRow"/>
        <body><![CDATA[
            this.removeRow(aRow);
        ]]></body>
      </method>

      <method name="removeRow">
        <parameter name="aRow"/>
        <body><![CDATA[
            this.getListItem(aRow).remove();
            this.fitDummyRows();
            this.mMaxFreeBusy--;
        ]]></body>
      </method>

      <!-- gets the next row from the top down -->
      <method name="getNextDummyRow">
        <body><![CDATA[
            let kids = this.childNodes;
            for (let i = 0; i < kids.length; ++i) {
                if (kids[i].hasAttribute("_isDummyRow")) {
                    return kids[i];
                }
            }
            return null;
        ]]></body>
      </method>

      <method name="fitDummyRows">
        <body><![CDATA[
            setTimeout(() => {
                this.calcContentHeight();
                this.createOrRemoveDummyRows();
            }, 0);
        ]]></body>
      </method>

      <method name="calcContentHeight">
        <body><![CDATA[
            let items = this.getElementsByTagName("richlistitem");
            this.mContentHeight = 0;
            if (items.length > 0) {
                let i = 0;
                do {
                    this.mRowHeight = items[i].getBoundingClientRect().height;
                    ++i;
                } while (i < items.length && !this.mRowHeight);
                this.mContentHeight = this.mRowHeight * items.length;
            }
        ]]></body>
      </method>

      <method name="createOrRemoveDummyRows">
        <body><![CDATA[
            let listboxHeight = this.getBoundingClientRect().height;

            // Remove rows to remove scrollbar
            let kids = this.childNodes;
            for (let i = kids.length - 1; this.mContentHeight > listboxHeight && i >= 0; --i) {
                if (kids[i].hasAttribute("_isDummyRow")) {
                    this.mContentHeight -= this.mRowHeight;
                    kids[i].remove();
                }
            }

            // Add rows to fill space
            if (this.mRowHeight) {
                while (this.mContentHeight + this.mRowHeight < listboxHeight) {
                    this.createDummyItem();
                    this.mContentHeight += this.mRowHeight;
                }
            }
        ]]></body>
      </method>

      <method name="createDummyItem">
        <body><![CDATA[
            let item = document.createElement("richlistitem");
            item.setAttribute("_isDummyRow", "true");
            item.setAttribute("class", "dummy-row");
            let cell = document.createElement("hbox");
            cell.setAttribute("flex", "1");
            cell.setAttribute("class", "addressingWidgetCell dummy-row-cell");
            item.appendChild(cell);
            this.appendChild(item);
            return item;
        ]]></body>
      </method>

      <method name="initTimeRange">
        <body><![CDATA[
            if (this.force24Hours) {
                this.mStartHour = 0;
                this.mEndHour = 24;
            } else {
                const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");

                this.mStartHour = Services.prefs.getIntPref("calendar.view.daystarthour", 8);
                this.mEndHour = Services.prefs.getIntPref("calendar.view.dayendhour", 19);
            }
        ]]></body>
      </method>
    </implementation>
  </binding>
</bindings>
