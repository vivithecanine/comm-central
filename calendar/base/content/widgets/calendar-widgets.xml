<?xml version="1.0" encoding="UTF-8"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!-- import-globals-from ../calendar-ui-utils.js -->
<!-- import-globals-from ../calendar-views-utils.js -->

<!DOCTYPE dialog [
  <!ENTITY % dtd1 SYSTEM "chrome://global/locale/global.dtd" > %dtd1;
  <!ENTITY % dtd2 SYSTEM "chrome://calendar/locale/calendar-event-dialog.dtd"> %dtd2;
]>

<bindings id="calendar-widgets"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <!-- this binding directly extends to a xul:box element and enriches this with some functionality: It is designed
      to be displayed only 1) in given application modes (e.g "task" mode, "calendar" mode) and 2) only in relation
      to the "checked" attribute of command or a checkbox control.
    - The attribute "mode" denotes a coma-separated list of all modes that the binding should not be collapsed in,
      e.g. mode="calendar,task"
    - The attribute "broadcaster" points to the id of a broadcaster that is supposed to be notified (by the application)
      as soon as the mode changes. When this happens the modebox" will be notified and will check if it should
      collapse itself or not.
    - The attribute "refcontrol" points to a control either a "command", "checkbox" or other
      elements that support a "checked" attribute that is often used to denote whether a modebox is supposed to be
      displayed or not. If "refcontrol" is set to the id of a command you can there set the oncommend attribute like:
      "oncommand='document.getElementById('my-mode-pane').togglePane(event)'. In case it is a checkbox element or derived
      checkbox element this is done automatically by listening to the event "CheckboxChange";
      So if the current application mode is one of the modes listed in the "mode" attribute it is
      additionally verified if the xul-element denoted by "refcontrol" is checked or not. During runtime an attribute named
      "collapsedinmodes" with the collpsed modes comma-separated e.g. "mail,calendar,task. This attribute is also made
      persistent-->
  <binding id="modebox">
    <implementation>
      <field name="mBroadcaster">null</field>;
      <field name="mModHandler">null</field>;
      <field name="mRefControl">null</field>;
      <field name="mControlHandler">null</field>;

      <constructor><![CDATA[
          if (this.hasAttribute("broadcaster")) {
              this.setAttribute("broadcaster", this.getAttribute("broadcaster"));
          }
          if (this.hasAttribute("refcontrol")) {
              this.mRefControl = document.getElementById(this.getAttribute("refcontrol"));
              if (this.mRefControl && (this.mRefControl.localName == "checkbox")) {
                  this.mControlHandler = {
                      binding: this,
                      handleEvent: function(aEvent, aHandled) {
                          return this.binding.onCheckboxStateChange(aEvent, this.binding);
                      }
                  };
                  this.mRefControl.addEventListener("CheckboxStateChange", this.mControlHandler, true);
              }
          }

          this.dispatchEvent(new CustomEvent("bindingattached", { bubbles: false }));
      ]]></constructor>

      <destructor><![CDATA[
          if (this.mBroadcaster) {
              this.mBroadcaster.removeEventListener("DOMAttrModified", this.mModHandler, true);
          }
          if (this.mRefControl) {
              this.mRefControl.removeEventListener("CheckboxStateChange", this.mControlHandler, true);
          }
      ]]></destructor>

      <property name="currentMode">
        <getter><![CDATA[
            if (this.mBroadcaster && this.mBroadcaster.hasAttribute("mode")) {
                return this.mBroadcaster.getAttribute("mode");
            } else {
                return "";
            }
        ]]></getter>
      </property>

      <method name="isVisible">
        <parameter name="aMode"/>
        <body><![CDATA[
            let lMode = aMode || this.currentMode;
            if (!this.isVisibleInMode(lMode)) {
                return false;
            }
            let collapsedModes = this.getAttribute("collapsedinmodes").split(",");
            return !collapsedModes.includes(lMode);
        ]]></body>
      </method>

      <method name="setModeAttribute">
        <parameter name="aModeAttribute"/>
        <parameter name="aModeValue"/>
        <parameter name="amode"/>
        <body><![CDATA[
            if (this.hasAttribute(aModeAttribute)) {
                let lMode = amode || this.currentMode;
                let modeAttributeValues = this.getAttribute(aModeAttribute).split(",");
                let modes = this.getAttribute("mode").split(",");
                modeAttributeValues[modes.indexOf(lMode)] = aModeValue;
                this.setAttribute(aModeAttribute, modeAttributeValues.join(","));
            }
        ]]></body>
      </method>

      <method name="getModeAttribute">
        <parameter name="aModeAttribute"/>
        <parameter name="aAttribute"/>
        <parameter name="amode"/>
        <body><![CDATA[
            if (this.hasAttribute(aModeAttribute)) {
                let lMode = amode || this.currentMode;
                let modeAttributeValues = this.getAttribute(aModeAttribute).split(",");
                let modes = this.getAttribute("mode").split(",");
                return modeAttributeValues[modes.indexOf(lMode)];
            } else {
                return "";
            }
        ]]></body>
      </method>

      <method name="setVisible">
        <parameter name="aVisible"/>
        <parameter name="aPushModeCollapsedAttribute"/>
        <parameter name="aNotifyRefControl"/>
        <body><![CDATA[
            let notifyRefControl = aNotifyRefControl == null || aNotifyRefControl === true;
            let pushModeCollapsedAttribute = aPushModeCollapsedAttribute == null ||
                                             aPushModeCollapsedAttribute === true;
            let collapsedModes = [];
            let modeIndex = -1;
            let display = aVisible;
            let collapsedInMode = false;
            if (this.hasAttribute("collapsedinmodes")) {
                collapsedModes = this.getAttribute("collapsedinmodes").split(",");
                modeIndex = collapsedModes.indexOf(this.currentMode);
                collapsedInMode = modeIndex > -1;
            }
            if (aVisible === true && !pushModeCollapsedAttribute) {
                display = (aVisible === true) && (!collapsedInMode);
            }

            setBooleanAttribute(this, "collapsed", !display || !this.isVisibleInMode());
            if (pushModeCollapsedAttribute) {
                if (!display) {
                    if (modeIndex == -1) {
                        collapsedModes.push(this.currentMode);
                        if (this.getAttribute("collapsedinmodes") == ",") {
                            collapsedModes.splice(0, 2);
                        }
                    }
                } else if (modeIndex > -1) {
                    collapsedModes.splice(modeIndex, 1);
                    if (collapsedModes.join(",") == "") {
                        collapsedModes[0] = ",";
                    }
                }
                this.setAttribute("collapsedinmodes", collapsedModes.join(","));

                // This binding is used all over the place. We can't guarantee that Services is available.
                var { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
                Services.xulStore.persist(this, "collapsedinmodes");
            }
            if (notifyRefControl === true) {
                if (this.hasAttribute("refcontrol")) {
                    let command = document.getElementById(this.getAttribute("refcontrol"));
                    if (command) {
                        command.setAttribute("checked", display);
                        setBooleanAttribute(command, "disabled", !this.isVisibleInMode());
                    }
                }
            }
        ]]></body>
      </method>

      <method name="isVisibleInMode">
        <parameter name="aMode"/>
        <body><![CDATA[
            let lMode = aMode || this.currentMode;
            let display = true;
            let lModes = [];
            if (this.hasAttribute("mode")) {
                let modeString = this.getAttribute("mode");
                lModes = modeString.split(",");
            }
            if (lModes && lModes.length > 0) {
                display = lModes.includes(lMode);
            }
            return display;
        ]]></body>
      </method>

      <method name="onModeModified">
        <parameter name="aEvent"/>
        <parameter name="aBinding"/>
        <body><![CDATA[
            if (aEvent.attrName == "mode") {
                let display = aBinding.isVisibleInMode(aEvent.newValue);
                aBinding.setVisible(display, false, true);
            }
        ]]></body>
      </method>

      <method name="togglePane">
        <parameter name="aEvent"/>
        <body><![CDATA[
            let command = aEvent.target;
            let newValue = (command.getAttribute("checked") == "true" ? "false" : "true");
            command.setAttribute("checked", newValue);
            this.setVisible(newValue == "true", true, true);
        ]]></body>
      </method>

      <method name="onCheckboxStateChange">
        <parameter name="aEvent"/>
        <parameter name="aBinding"/>
        <body><![CDATA[
            let newValue = aEvent.target.checked;
            this.setVisible(newValue, true, true);
        ]]></body>
      </method>

      <method name="setAttribute">
        <parameter name="aAttr"/>
        <parameter name="aVal"/>
        <body><![CDATA[
            if (aAttr == "broadcaster") {
                this.mBroadcaster = document.getElementById(aVal);
                if (this.mBroadcaster) {
                    this.mModHandler = {
                        binding: this,
                        handleEvent: function(aEvent, aHandled) {
                            return this.binding.onModeModified(aEvent, this.binding);
                        }
                    };
                    this.mBroadcaster.addEventListener("DOMAttrModified", this.mModHandler, true);
                }
            }
            return XULElement.prototype.setAttribute.call(this, aAttr, aVal);
        ]]></body>
      </method>
    </implementation>
  </binding>
</bindings>
