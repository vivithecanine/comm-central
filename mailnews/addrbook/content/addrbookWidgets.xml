<?xml version="1.0"?>
<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<bindings id="addrbookBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="addrbooks-menupopup"
           extends="chrome://global/content/bindings/popup.xml#popup">
    <implementation implements="nsIAbListener">
      <!-- A cache of nsIAbDirectory objects. -->
      <field name="_directories">[]</field>

      <!-- Represents the nsIAbDirectory attribute used as the value of the
           parent menulist. Defaults to URI but can be e.g. dirPrefId -->
      <field name="_value">this.getAttribute("value") || "URI"</field>

      <field name="_stringBundle">null</field>

      <constructor>
        <![CDATA[
          ChromeUtils.import("resource:///modules/MailServices.jsm", this);
          ChromeUtils.import("resource:///modules/iteratorUtils.jsm", this);
          ChromeUtils.import("resource:///modules/StringBundle.js", this);
          this._stringBundle = new this
              .StringBundle("chrome://messenger/locale/addressbook/addressBook.properties");

          this._rebuild();
          const nsIAbListener = Ci.nsIAbListener;
          // Add a listener so we can update correctly if the list should change
          this.MailServices.ab
              .addAddressBookListener(this,
                                      nsIAbListener.itemAdded |
                                      nsIAbListener.directoryItemRemoved |
                                      nsIAbListener.directoryRemoved |
                                      nsIAbListener.itemChanged);
        ]]>
      </constructor>

      <destructor>
        <![CDATA[
          this.MailServices.ab.removeAddressBookListener(this);

          this._teardown();
        ]]>
      </destructor>

      <method name="_rebuild">
        <parameter name="aSelectValue"/>
        <body><![CDATA[
          // Init the address book cache.
          this._directories.length = 0;
          const nsIAbDirectory = Ci.nsIAbDirectory;
          let directories = this.MailServices.ab.directories;
          while (directories && directories.hasMoreElements()) {
            let ab = directories.getNext();
            if ((ab instanceof nsIAbDirectory) && this._matches(ab)) {
              this._directories.push(ab);
              if (this.getAttribute("mailinglists") == "true") {
                // Also append contained mailinglists.
                for (let list of this.fixIterator(ab.childNodes, Ci.nsIAbDirectory)) {
                  if (this._matches(list))
                    this._directories.push(list);
                }
              }
            }
          }

          this._sort();

          this._teardown();

          let menulist = this.parentNode;
          // Force initialization of the menulist custom element first.
          customElements.upgrade(menulist);

          if (this.hasAttribute("none")) {
            // Create a dummy menuitem representing no selection.
            this._directories.unshift(null);
            let listItem = menulist.appendItem(this.getAttribute("none"), "");
            listItem.setAttribute("class", "menuitem-iconic abMenuItem");
            listItem.setAttribute("IsNone", "true");
          }

          if (this.hasAttribute("alladdressbooks")) {
            // Insert a menuitem representing All Addressbooks.
            let allABLabel = this.getAttribute("alladdressbooks");
            if (allABLabel == "true")
              allABLabel = this._stringBundle.getString("allAddressBooks");
            const allABURI = "moz-abdirectory://?";
            this._directories.unshift(null);
            let listItem = menulist.appendItem(allABLabel, allABURI);
            listItem.setAttribute("class", "menuitem-iconic abMenuItem");
            listItem.setAttribute("AddrBook", "true");
            listItem.setAttribute("IsAllAB", "true");
          }

          // Now create menuitems for all displayed directories.
          let value = this._value;
          for (let ab of this._directories) {
            if (!ab) // Skip the empty members added above.
              continue;

            let listItem = menulist.appendItem(ab.dirName, ab[value]);
            listItem.setAttribute("class", "menuitem-iconic abMenuItem");

            // Style the items by type.
            if (ab.isMailList)
              listItem.setAttribute("MailList", "true");
            else
              listItem.setAttribute("AddrBook", "true");

            if (ab.isRemote)
              listItem.setAttribute("IsRemote", "true");
            if (ab.isSecure)
              listItem.setAttribute("IsSecure", "true");
          }

          // Attempt to select the persisted or otherwise first directory.
          menulist.value = aSelectValue || this.parentNode.value;
          if (!menulist.selectedItem && this.hasChildNodes())
            menulist.selectedIndex = 0;
        ]]></body>
      </method>

      <method name="_teardown">
        <body><![CDATA[
          // Empty out anything in the list.
          // (Don't use menulist.removeAllItems() as it would remove
          // the menupopup with our special attributes too.)
          while (this.hasChildNodes())
            this.lastChild.remove();
        ]]></body>
      </method>

      <!-- nsIAbListener methods -->
      <method name="onItemAdded">
        <parameter name="aParentDir"/>
        <parameter name="aItem"/>
        <body><![CDATA[
          // Are we interested in this new directory?
          if (aItem instanceof Ci.nsIAbDirectory &&
              this._matches(aItem)) {
            this._rebuild();
          }
        ]]></body>
      </method>

      <method name="onItemRemoved">
        <parameter name="aParentDir"/>
        <parameter name="aItem"/>
        <body><![CDATA[
          if (aItem instanceof Ci.nsIAbDirectory) {
            // Find the item in the list to remove.
            // We can't use indexOf here because we need loose equality.
            for (var index = this._directories.length; --index >= 0;)
              if (this._directories[index] == aItem)
                break;
            if (index != -1) {
              this._directories.splice(index, 1);
              // Are we removing the selected directory?
              if (this.parentNode.selectedItem ==
                  this.removeChild(this.childNodes[index])) {
                // If so, try to select the first directory, if available.
                if (this.hasChildNodes())
                  this.firstChild.doCommand();
                else
                  this.parentNode.selectedItem = null;
              }
            }
          }
        ]]></body>
      </method>

      <method name="onItemPropertyChanged">
        <parameter name="aItem"/>
        <parameter name="aProperty"/>
        <parameter name="aOldValue"/>
        <parameter name="aNewValue"/>
        <body><![CDATA[
          if (aItem instanceof Ci.nsIAbDirectory) {
            // Find the item in the list to rename.
            // We can't use indexOf here because we need loose equality.
            for (var oldIndex = this._directories.length; --oldIndex >= 0;)
              if (this._directories[oldIndex] == aItem)
                break;
            if (oldIndex != -1)
              this._rebuild();
          }
        ]]></body>
      </method>

      <!-- Private methods -->
      <!-- Tests to see whether this directory should display in the list. -->
      <method name="_matches">
        <parameter name="ab"/>
        <body><![CDATA[
          // This condition is used for instance when creating cards
          if (this.getAttribute("writable") == "true" && ab.readOnly)
            return false;

          // This condition is used for instance when creating mailing lists
          if (this.getAttribute("supportsmaillists") == "true" &&
              !ab.supportsMailingLists)
            return false;

          return this.getAttribute(ab.isRemote ? "localonly" : "remoteonly") != "true";
        ]]></body>
      </method>

      <!-- Sort all our directories. -->
      <method name="_sort">
        <body><![CDATA[
          let lists = {};
          let lastAB;
          // If there are any mailing lists, pull them out of the array temporarily.
          for (let d = 0; d < this._directories.length; d++) {
            if (this._directories[d].isMailList) {
              let [list] = this._directories.splice(d, 1);
              if (!(lastAB in lists))
                lists[lastAB] = [];
              lists[lastAB].push(list);
              d--;
            } else {
              lastAB = this._directories[d].URI;
            }
          }

          this._directories.sort(this._compare);

          // Push mailing lists back appending them after their respective
          // containing addressbook.
          for (let d = this._directories.length - 1; d >= 0; d--) {
            let abURI = this._directories[d].URI;
            if (abURI in lists) {
              lists[abURI].sort(function(a, b) { return a.dirName.localeCompare(b.dirName); });
              let listIndex = d;
              for (let list of lists[abURI]) {
                listIndex++;
                this._directories.splice(listIndex, 0, list);
              }
              delete lists[abURI];
            }
          }
        ]]></body>
      </method>

      <!-- Used to sort directories in order -->
      <method name="_compare">
        <parameter name="a"/>
        <parameter name="b"/>
        <body><![CDATA[
          // Null at the very top.
          if (!a)
            return -1;

          if (!b)
            return 1;

          // Personal at the top.
          const kPersonalAddressbookURI = "moz-abmdbdirectory://abook.mab";
          if (a.URI == kPersonalAddressbookURI)
            return -1;

          if (b.URI == kPersonalAddressbookURI)
            return 1;

          // Collected at the bottom.
          const kCollectedAddressbookURI = "moz-abmdbdirectory://history.mab";
          if (a.URI == kCollectedAddressbookURI)
            return 1;

          if (b.URI == kCollectedAddressbookURI)
            return -1;

          // Sort books of the same type by name.
          if (a.dirType == b.dirType)
            return a.dirName.localeCompare(b.dirName);

          // If one of the dirTypes is PAB and the other is something else,
          // then the other will go below the one of type PAB.
          const PABDirectory = 2;
          if (a.dirType == PABDirectory)
            return -1;

          if (b.dirType == PABDirectory)
            return 1;

          // Sort anything else by the dir type.
          return a.dirType - b.dirType;
        ]]></body>
      </method>
    </implementation>
  </binding>
</bindings>
