<?xml version="1.0"?>

<!-- This Source Code Form is subject to the terms of the Mozilla Public
   - License, v. 2.0. If a copy of the MPL was not distributed with this
   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->

<!--
  This file has the following external dependencies:
      -gFilterActionStrings from FilterEditor.js
      -gFilterList from FilterEditor.js
      -gFilter from FilterEditor.js
      -gCustomActions from FilterEditor.js
      -gFilterType from FilterEditor.js
      -checkActionsReorder from FilterEditor.js
-->
<!-- import-globals-from FilterEditor.js -->

<!DOCTYPE dialog [
  <!ENTITY % filterEditorDTD SYSTEM "chrome://messenger/locale/FilterEditor.dtd" >
%filterEditorDTD;
  <!ENTITY % messengerDTD    SYSTEM "chrome://messenger/locale/messenger.dtd" >
%messengerDTD;
]>

<bindings id="filterBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <!-- This binding exists to disable the default binding of a richlistitem
       in the search terms. -->
  <binding id="filterlistitem" extends="chrome://global/content/bindings/richlistbox.xml#richlistitem">
    <implementation>
      <property name="selected" onget="return false;">
        <setter>
          <![CDATA[
            /* This provides a dummy selected property that
               the listbox expects to be able to call.
               See bug 202036. */
          ]]>
        </setter>
      </property>

      <method name="_fireEvent">
        <parameter name="aName"/>
        <body>
          <![CDATA[
            /* This provides a dummy _fireEvent function that
               the listbox expects to be able to call.
               See bug 202036. */
          ]]>
        </body>
      </method>
    </implementation>
  </binding>

  <binding id="ruleaction" extends="#filterlistitem">
    <content allowevents="true">
      <xul:menulist is="ruleactiontype-menulist" flex="&filterActionTypeFlexValue;">
        <xul:menupopup>
          <xul:menuitem label="&moveMessage.label;" value="movemessage" enablefornews="false"/>
          <xul:menuitem label="&copyMessage.label;" value="copymessage"/>
          <xul:menuseparator enablefornews="false"/>
          <xul:menuitem label="&forwardTo.label;" value="forwardmessage" enablefornews="false"/>
          <xul:menuitem label="&replyWithTemplate.label;" value="replytomessage" enablefornews="false"/>
          <xul:menuseparator/>
          <xul:menuitem label="&markMessageRead.label;" value="markasread"/>
          <xul:menuitem label="&markMessageUnread.label;" value="markasunread"/>
          <xul:menuitem label="&markMessageStarred.label;" value="markasflagged"/>
          <xul:menuitem label="&setPriority.label;" value="setpriorityto"/>
          <xul:menuitem label="&addTag.label;" value="addtagtomessage"/>
          <xul:menuitem label="&setJunkScore.label;" value="setjunkscore" enablefornews="false"/>
          <xul:menuseparator enableforpop3="true"/>
          <xul:menuitem label="&deleteMessage.label;" value="deletemessage"/>
          <xul:menuitem label="&deleteFromPOP.label;" value="deletefrompopserver" enableforpop3="true"/>
          <xul:menuitem label="&fetchFromPOP.label;" value="fetchfrompopserver" enableforpop3="true"/>
          <xul:menuseparator/>
          <xul:menuitem label="&ignoreThread.label;" value="ignorethread"/>
          <xul:menuitem label="&ignoreSubthread.label;" value="ignoresubthread"/>
          <xul:menuitem label="&watchThread.label;" value="watchthread"/>
          <xul:menuseparator/>
          <xul:menuitem label="&stopExecution.label;" value="stopexecution"/>
        </xul:menupopup>
      </xul:menulist>
      <xul:ruleactiontarget-wrapper xbl:inherits="type=value"
                                    class="ruleactiontarget"
                                    flex="&filterActionTargetFlexValue;"/>
      <xul:hbox>
        <xul:button class="small-button"
                    label="+"
                    tooltiptext="&addAction.tooltip;"
                    oncommand="this.parentNode.parentNode.addRow();"/>
        <xul:button class="small-button"
                    label="&#x2212;"
                    tooltiptext="&removeAction.tooltip;"
                    oncommand="this.parentNode.parentNode.removeRow();"
                    anonid="removeButton"/>
      </xul:hbox>
    </content>

    <implementation>
      <field name="mListBox">this.parentNode</field>
      <field name="mRemoveButton">document.getAnonymousElementByAttribute(this, "anonid", "removeButton")</field>
      <field name="mActionTypeInitialized">false</field>
      <field name="mRuleActionTargetInitialized">false</field>
      <field name="mRuleActionType">document.getAnonymousNodes(this)[0]</field>

      <method name="clearInitialActionIndex">
        <body>
          <![CDATA[
            // we should only remove the initialActionIndex after we have been told that
            // both the rule action type and the rule action target have both been built since they both need
            // this piece of information. This complication arises because both of these child elements are getting
            // bound asynchronously after the search row has been constructed

            if (this.mActionTypeInitialized && this.mRuleActionTargetInitialized)
              this.removeAttribute("initialActionIndex");
          ]]>
        </body>
      </method>

      <method name="initWithAction">
        <parameter name="aFilterAction"/>
        <body>
          <![CDATA[
            var filterActionStr;
            var actionTarget = document.getAnonymousNodes(this)[1];
            let actionItem = actionTarget.ruleactiontargetElement;
            var nsMsgFilterAction = Ci.nsMsgFilterAction;
            switch (aFilterAction.type) {
              case nsMsgFilterAction.Custom:
                filterActionStr = aFilterAction.customId;
                if (actionItem)
                  actionItem.childNodes[0].value = aFilterAction.strValue;

                // Make sure the custom action has been added. If not, it
                // probably was from an extension that has been removed. We'll
                // show a dummy menuitem to warn the user.
                var needCustomLabel = true;
                for (let i = 0; i < gCustomActions.length; i++) {
                  if (gCustomActions[i].id == filterActionStr) {
                    needCustomLabel = false;
                    break;
                  }
                }
                if (needCustomLabel) {
                  var menuitem = document.createElementNS(
                      "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                      "xul:menuitem");
                  menuitem.setAttribute("label",
                      gFilterBundle.getString("filterMissingCustomAction"));
                  menuitem.setAttribute("value", filterActionStr);
                  menuitem.disabled = true;
                  this.mRuleActionType.menupopup.appendChild(menuitem);
                  var scriptError = Cc["@mozilla.org/scripterror;1"]
                      .createInstance(Ci.nsIScriptError);
                  scriptError.init("Missing custom action " + filterActionStr,
                      null, null, 0, 0,
                      Ci.nsIScriptError.errorFlag,
                      "component javascript");
                  Services.console.logMessage(scriptError);
                }
                break;
              case nsMsgFilterAction.MoveToFolder:
              case nsMsgFilterAction.CopyToFolder:
                actionItem.childNodes[0].value = aFilterAction.targetFolderUri;
                break;
              case nsMsgFilterAction.Reply:
              case nsMsgFilterAction.Forward:
                actionItem.childNodes[0].value = aFilterAction.strValue;
                break;
              case nsMsgFilterAction.Label:
                actionItem.childNodes[0].value = aFilterAction.label;
                break;
              case nsMsgFilterAction.ChangePriority:
                actionItem.childNodes[0].value = aFilterAction.priority;
                break;
              case nsMsgFilterAction.JunkScore:
                actionItem.childNodes[0].value = aFilterAction.junkScore;
                break;
              case nsMsgFilterAction.AddTag:
                actionItem.childNodes[0].value = aFilterAction.strValue;
                break;
              default:
                break;
            }
            if (aFilterAction.type != nsMsgFilterAction.Custom)
              filterActionStr = gFilterActionStrings[aFilterAction.type];
            this.mRuleActionType.value = filterActionStr;
            this.mRuleActionTargetInitialized = true;
            this.clearInitialActionIndex();
            checkActionsReorder();
          ]]>
        </body>
      </method>

      <method name="validateAction">
        <body>
          <![CDATA[
            // returns true if this row represents a valid filter action and false otherwise.
            // This routine also prompts the user.
            ChromeUtils.import("resource:///modules/MailUtils.jsm", this);
            var filterActionString = this.getAttribute("value");
            var actionTarget = document.getAnonymousNodes(this)[1];
            let actionTargetLabel = actionTarget.ruleactiontargetElement &&
                                    actionTarget.ruleactiontargetElement.childNodes[0].value;
            var errorString, customError;

            switch (filterActionString) {
              case "movemessage":
              case "copymessage":
                let msgFolder = actionTargetLabel ?
                  this.MailUtils.getOrCreateFolder(actionTargetLabel) : null;
                if (!msgFolder || !msgFolder.canFileMessages)
                  errorString = "mustSelectFolder";
                break;
              case "forwardmessage":
                if (actionTargetLabel.length < 3 ||
                    actionTargetLabel.indexOf("@") < 1)
                  errorString = "enterValidEmailAddress";
                break;
              case "replytomessage":
                if (!actionTarget.ruleactiontargetElement.childNodes[0].selectedItem)
                   errorString = "pickTemplateToReplyWith";
                break;
              default:
                // some custom actions have no action value node
                if (!document.getAnonymousNodes(actionTarget))
                  return true;
                // locate the correct custom action, and check validity
                for (let i = 0; i < gCustomActions.length; i++) {
                  if (gCustomActions[i].id == filterActionString) {
                    customError =
                        gCustomActions[i].validateActionValue(
                          actionTargetLabel,
                          gFilterList.folder, gFilterType);
                    break;
                  }
                }
                break;
            }

            errorString = errorString ?
                          gFilterBundle.getString(errorString) :
                          customError;
            if (errorString)
              Services.prompt.alert(window, null, errorString);

            return !errorString;
          ]]>
        </body>
      </method>

      <method name="saveToFilter">
        <parameter name="aFilter"/>
        <body>
          <![CDATA[
            // create a new filter action, fill it in, and then append it to the filter
            var filterAction = aFilter.createAction();
            var filterActionString = this.getAttribute("value");
            filterAction.type = gFilterActionStrings.indexOf(filterActionString);
            var actionTarget = document.getAnonymousNodes(this)[1];
            let actionItem = actionTarget.ruleactiontargetElement;
            var nsMsgFilterAction = Ci.nsMsgFilterAction;
            switch (filterAction.type) {
              case nsMsgFilterAction.Label:
                filterAction.label = actionItem.childNodes[0].getAttribute("value");
                break;
              case nsMsgFilterAction.ChangePriority:
                filterAction.priority = actionItem.childNodes[0].getAttribute("value");
                break;
              case nsMsgFilterAction.MoveToFolder:
              case nsMsgFilterAction.CopyToFolder:
                filterAction.targetFolderUri = actionItem.childNodes[0].value;
                break;
              case nsMsgFilterAction.JunkScore:
                filterAction.junkScore = actionItem.childNodes[0].value;
                break;
              case nsMsgFilterAction.Custom:
                filterAction.customId = filterActionString;
                // fall through to set the value
              default:
                if (actionItem && actionItem.childNodes.length > 0)
                  filterAction.strValue = actionItem.childNodes[0].value;
                break;
              }
            aFilter.appendAction(filterAction);
          ]]>
        </body>
      </method>

      <method name="getActionStrings">
        <parameter name="aActionStrings"/>
        <body>
          <![CDATA[
            // Collect the action names and arguments in a plain string form.
            let actionTarget = document.getAnonymousNodes(this)[1];
            let actionItem = actionTarget.ruleactiontargetElement;
            let actionItemLabel = actionItem && actionItem.childNodes[0].label;

            let actionString = {
              label: this.mRuleActionType.label,
              argument: "",
            };
            if (actionItem) {
              if (actionItemLabel) {
                actionString.argument = actionItemLabel;
              } else {
                actionString.argument = actionItem.childNodes[0].value;
              }
            }
            aActionStrings.push(actionString);
          ]]>
        </body>
      </method>

      <method name="updateRemoveButton">
        <body>
          <![CDATA[
            // if we only have one row of actions, then disable the remove button for that row
            this.mListBox.getItemAtIndex(0).mRemoveButton.disabled = this.mListBox.getRowCount() == 1;
          ]]>
        </body>
      </method>

      <method name="addRow">
        <body>
          <![CDATA[
            let listItem = document.createXULElement("richlistitem");
            listItem.className = "ruleaction";
            listItem.setAttribute("onfocus", "this.storeFocus();");
            this.mListBox.insertBefore(listItem, this.nextSibling);
            this.mListBox.ensureElementIsVisible(listItem);

            // make sure the first remove button is enabled
            this.updateRemoveButton();
            checkActionsReorder();
          ]]>
        </body>
      </method>

      <method name="removeRow">
        <body>
          <![CDATA[
            // this.mListBox will fail after the row is removed, so save it
            let listBox = this.mListBox;
            if (listBox.getRowCount() > 1)
              this.remove();
            // can't use 'this' as it is destroyed now
            listBox.getItemAtIndex(0).updateRemoveButton();
            checkActionsReorder();
          ]]>
        </body>
      </method>

      <method name="storeFocus">
        <body>
          <![CDATA[
            // When this action row is focused, store its index in the parent listbox.
            this.mListBox.setAttribute("focusedAction", this.mListBox.getIndexOfItem(this));
          ]]>
        </body>
      </method>

    </implementation>
  </binding>

</bindings>
